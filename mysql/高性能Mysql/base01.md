# Base 01



## 间歇性问题分析：

### 方法：

1. show global status: `mysqladmin ext -i1 -uroot -proot | awk '/Queries/{q=$4-qp;qp=$4}/Threads_connected/{tc=$4}/Threads_running/{printf "%5d %5d %5d\n", q, tc, $4}'`，此命令每秒捕获一次 SHOW GLOBAL STATUS 的数据，输出出来
2. show processlist: `mysql -e 'show processlist\G' -uroot -proot |grep 'State'|sort|uniq -c| sort -rn`， 此命令不停的捕获 SHOW PROCESSLIST 的输出，来观察是否有大量线程处于不正常状态或者有其他不正常的特征。（例如：查询很少会长时间处于 `statistics`状态，此状态一般很快；也很少见到大量线程报告当前连接用户是 “未经验证的用户”）
   1. 大量线程处于 `freeing items`状态是出现了大量有问题查询的很明显的特征。
   2. 也可以在 information_schema下的PROCESSLIST表中查看线程情况
3. 使用查询日志：`awk '/^# Time:/{print $3, $4, c;c=0}/^# User/{c++}' /var/lib/mysql/2ba3731e4a26-slow.log`，此命令可以根据MySQL每秒将当前时间写入日志中的模式统计每秒的查询数量。使用查询日志的前置操作：
   1. 开启慢查询日志
   2. 设置全局级别`long_query_time=0`
   3. 重置所有连接

### 触发器

1. 合适的触发器
2. 合适的阈值，不宜过高或过低（不要将阈值设置在刚好发生问题的地方，发生问题的上升趋势更重要）

### 收集什么样的数据

- 系统状态
- CPU利用率
- 磁盘利用率、可用空间
- ps的输出采样
- 内存利用率
- mysql信息
  - SHOW STATUS
  - SHOW PROCESSLIST
  - SHOW INNODB STATUS

可能还有更多



## 高性能的索引

### 独立的列

指索引不能用于表达式中，如：where id + 1 = 6;

### 前缀索引

前缀索引常用于一些内容很长但经常检索的列上，即选择字段的前面部分作为索引值

如：alter table student add key (description(10));

即：在student的description字段的前10个内容作索引

这种索引需要注意：不能选择过短，这样会使得值命中太多；也不能选择过长，过长会退化成普通的索引，无意义。

### 多列索引

错误情况：给每一个列都设置索引 or 设置错误的列顺序的多列索引

#### 选择合适的索引列顺序

> 将**选择性最高**的列放到索引最前列

```mysql
SELECT
	COUNT( DISTINCT firstname )/ COUNT(*) AS firstname_selectivity,
	COUNT( DISTINCT lastname )/ COUNT(*) AS lastname_selectivity,
	COUNT(*) 
FROM
	student;
```

上面的sql得到的结果如下图

![image-20230620154736423](/Users/wangxiang/Library/Application Support/typora-user-images/image-20230620154736423.png)

从中可以得到，lastname的选择性更高，所以索引列应该设置成：

```mysql
alter table student add key (lastname, firstname);
```

### 聚簇索引

聚簇索引非某种具体的索引，而是一种索引的实现方式，每个表中只能有一个聚簇索引



## 查优化

> 上层优化（代码层面或更上层），建立最优表结构，建立最优索引

1. mysql如何查询；
2. 高效、低效的原因。

如果把查询看作一个任务，这个任务由一系列任务组成。那么对查询的优化其实就是：

1. 消除一部分子任务；
2. 减少子任务执行次数；
3. 让子任务执行的更快。

### 子任务

查询的子任务主要分为：
从客户端到服务器；服务器解析；生成执行计划；**执行**；返回给客户端。

其中最重要的为执行部分。

### 慢查询

> 优化数据访问

查询性能低的最基本，最常见的原因是访问数据量过大，可以通过以下方式来检验

1. 确认是否在检索大量超过需要的数据，即访问了过多的行或列；
2. 确认mysql是否在分析大量超过需要的数据行。

#### 访问了过多的行

很多时候，会查询过多的行，然后丢弃掉不需要的部分。这样既增加了查询的负担又增加了网络开销。

##### 查询了不需要的记录

比如分页查询：使用limit，而不是全部查询出来，不需要的再丢弃

##### 多表查询时返回全部列

多表查询的时候，只返回需要的信息，不要过多的返回不用的信息

如直接使用 * 会返回所有联合的表的所有记录

##### 返回全部列

每次 `SELECT *`的时候都抱着怀疑的态度，“我是否真的需要所有的字段”

##### 重复查询

比如经典的在 for循环里写select

#### MySQL是否在扫描额外的记录

衡量mysql查询开销的三个指标：

1. 响应时间
2. 扫描行数
3. 返回行数

> 以上三个指标都会记录到慢日志中

##### 响应时间

响应时间 = 排队时间 + 服务时间

排队时间：等待 I/O时间；等待锁时间等等

服务时间：真正执行花费的时间

##### 扫描行数 & 返回行数

一般扫描行数：返回行数 在 1:1 到 10:1之间

如果发现扫描了大量数据，但只返回少量数据可以：

1. 使用索引覆盖扫描，把所有需要用的列都放到索引里；
2. 改变库表结构。例如使用单独的汇总表；
3. 重写复杂查询，让MySQL优化器能以更加优化的方式执行这个查询。

### 重构查询方式

#### 一个复杂查询还是多个简单查询

在以往总是想让数据库完成尽可能多的任务，是因为当时网络通信、查询解析和优化等很耗时

现在数据库优化的很好，配置进步的也很快，网卡等的响应能力也很强，所以将一个复杂查询优化成多个简单查询也是完全可行的。

#### 切分查询

将一个大查询分成多个小查询，每个查询功能相同，返回部分结果

#### 分解关联查询

即：对每个单表进行查询，在代码里做关联操作。这样做的好处：

- 利用缓存
- 减少对锁的竞争
- 这样对数据库的侵入比较小，更容易对数据库做拆分
- 查询本身效率提升
- 可以减少冗余记录查询

### 查询执行基础

#### 一条查询的整个过程

1. 客户端发送一条查询命令到服务器；
2. 服务器先检查缓存，如果命中则直接返回；
3. 服务器执行解析、预处理，再由优化器生成对应的执行计划；
4. MySQL根据优化器生成的执行计划，调用存储引擎的API执行查询操作；
5. 将结果返回给客户端。
