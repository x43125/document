# 优化

## 索引失效的场景

1. 使用否定查询：not in
2. 使用前导模糊搜索：like ‘%mysql’; like ‘%mysq%’

3. 在字段上进行计算：where id + 1 < 10

4. 最左前缀原则：使用联合索引的时候，要从左向后过滤（顺序无所谓）如：联合索引：`username, pwd` 

   那么在检索的时候：where username=‘asd’ and pwd=‘123’ 或 where pwd=‘123’ and username=‘asd’ 或 where username=‘asd’ **会**命中此联合索引

   where pwd=‘123’**不会**命中此联合索引

5. 不让数据库做类型转换：where name=1234 应该改为 where name=‘1234’

6. 如果做join操作，两表的join字段类型也要相同，否则不会走索引

## 建议

3. 如果一个字段没有明确区分，即可能大多数值都是一样的，那不建议创建索引，如：性别
4. 字段值的默认值不要设置成 null,这样可能搜索结果会和预期不同
5. 如果明确知道只会返回一条记录可以用limit来提前结束数据库的扫描：limit 1

## 宏观建议

1. 使用EXPLAIN分析
2. 使用慢查询日志分析
3. 减少请求的数据量
4. 减少服务器端扫描的行术
5. 切分大查询（分成多次功能相同的小查询）
6. 分解大连接查询（单表查询，在程序里关联）







## SQL优化步骤

### 1、慢SQL发现

#### 1.0 应用层

性能调优金字塔：应用层调优 -> 数据库调优 -> 硬件调优

> 成本越来越高，效果越来越低。

“慢”一般都是从上层发现的接口返回很慢，那可以从上到下先看是否是网络问题，然后看是否是业务代码逻辑写的不好导致的慢。即“慢”是发生在哪一步的？

一般业务层的代码优化可以解决大部分的问题，比如：

- 是否将查询放到了for循环里
- 是否一次查询了过多的用不到的数据，比如全表查询
- 是否粗略的select * 返回了所有列等等

#### 1.1 慢查询日志

可以配置成日志形式，或是直接记录在表中

#### 1.2 EXPLAIN 执行计划

当定位到慢SQL后可以使用EXPLAIN命令来查看该SQL的执行计划从而能定位到该SQL为什么慢

### 2、SQL优化

#### 2.1 应用层



#### 2.2 SQL

##### SQL优化宗旨

1. 减少数据访问
2. 返回更少的数据
3. 减少交互次数
4. 减少CPU开销
5. 利用更多资源

再精炼即：

1. 最大化利用索引
2. 尽可能避免全表扫描
3. 减少无效数据的查询

##### 具体的执行：

1. 避免不走索引的情况
   1. 避免使用 like (‘%开头’)的场景，如果业务必须使用可以：
      1. 使用FULLTEXT全文索引，用match against检索
      2. 数据量较大的时候，使用Solr,ES等搜索引擎
      3. 数据量小直接使用
   2. 联合索引未满足最左原则
   3. 使用 select * 会避免掉覆盖索引的情况
   4. 索引列参与计算
   5. 索引列使用了函数
   6. 类型隐式转换：特例：字段为int，即使where条件用了单或双引号，也会走索引
   7. 使用or字段：两边的字段都需要加索引，否则不会走索引
   8. 两列字段做比较：即使都有索引也会失效
   9. 不等于比较 （主键特例）
   10. is not null
   11. not exists; not in （主键特例）
   12. order by （主键特例）
   13. 当检索结果数量超过数据库总量的10%～30%的时候，则有可能直接走全表扫描
2. 避免使用select * 
3. 多表关联查询的时候，小表在前，大表在后
4. 用where避免having
5. where条件里，将可以过滤大量数据的条件提前，因为where的执行是从左到右的
6. DML语句优化
   1. 大量数据插入，建议走批量插入方式
   2. 适当commit，如大量删除数据的时候
   3. 避免重复查询更新的数据：如想知道更新的结果的时候，可以使用变量
      1. update t1 set time=now() where col1=1 and @now:=now();
      2. select @now;
7. 对于过于复杂的查询，可以使用中间表
8. 使用join代替子查询
9. 除非必要，使用uninon all 而非union
10. 拆分大SQL，使用多个小SQL
11. 使用truncate代替delete
12. 建表优化
    1. 建索引
       1. 优先考虑where、order by 的字段
    2. 尽量使用数字类型





千万级大表查询优化

1. 优化sql & 索引
2. 加缓存
3. 读写分离等
4. mysql自带的分区表使用下看看
5. 先垂直拆分
6. 水平拆分
