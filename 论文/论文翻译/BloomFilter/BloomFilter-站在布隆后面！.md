# BloomFilter - 站在布隆后面！

## 大纲

1. 站在布隆后面
2. 介绍
3. hash结构的 不可能三角
4. 实现
5. 错误率计算公式 -> 各个参数的选择（k,n,m）
6. 优缺点
7. 改良
8. 使用场景



## 一、站在布隆后面

![布隆](/Users/wangxiang/Downloads/布隆.png)

首先让我用一个游戏角色及他的一句对白来开始今天的分享，这是游戏《英雄联盟》中的一名英雄--布隆，他在游戏中的一句经典对白就是：“站在布隆后面”，玩家可以使用这名英雄举起他的巨大盾牌站在队友面前保护队友免受敌方的伤害。而我们今天要介绍的内容也是和他这一特点有一定相似之处的 -- 布隆过滤器

## 二、布隆过滤器

布隆过滤器是一位名叫布隆（BURTON H. BLOOM）的大兄弟于1970年发布的论文上提到的，文章中提出了两种hash结构来讨论传统的hash结构需要占用大量空间的问题。

### 2.1 Hash

说到此处，让我们先来回顾一下朝夕相处的Hash结构，hash结构通过函数映射实现了常数级时间复杂度的查询，即传一个值过来通过函数计算得出他在表中应该存储的位置。查询的时候类似，使用函数计算得到存储位置，去到指定位置检索即可。在这些过程中如果发生了hash冲突，也可以通过再散列法、链表法等解决冲突，是一种100%正确的结构，对于传进来的值可以绝对的确定其存在与否。

那这种结构不是已经很好了吗，为什么还需要新的结构？

Hash结构的缺点或者不足：

  1、范围查询支持不是很好：因为其存储的值是通过函数映射得到的，所以每一个值在表中的位置都得经过计算才能得到，因此范围查询效率不是很高（在mysql数据库引擎中对应的就有B+树的索引结构）；

  2、空间占用较大：因为会发生hash冲突，为了绝对正确的判断，需要存储实际值用于比较。这针对那些只需要判断传入值是否存在的问题来说，占用的空间就有点大了，布隆过滤器即是对这一点做的改进。

### 2.2 布隆过滤器

布隆过滤器想必大家即使没有使用过，也不会太陌生。通常来说，我们的很多操作其实就是在空间换时间，时间换空间，而布隆过滤器加入了一种新的属性：**正确率**。布隆过滤器提出，如果可以适当的放弃一部分正确率，则可以在保留时间复杂度的基础上，极大的减少空间的使用。关于正确率的具体的内容让我们后面在慢慢讨论。

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf1.jpg)

布隆过滤器：给定一个初始全为0的位数组，将加入的值通过多次hash散列得到多个数字，将数字对应下标位置的数组值置为1。在查询的时候，依然使用这些散列函数得到多个值，如果表中对应的所有位置中有**任意**一个值为0，则表示该值**肯定不存在**，如果所有位置的值都为1则表示**可能**存在该值，是否真的存在，需要进一步判断。

如下图中，x1、x2被散列到了如图的几个位置，由于存在hash冲突，x1,x2有部分点位共用。

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf2.jpg)

此时判断y1,y2两值，经过计算后得到如图映射，则y1有0值必然不存在，而y2则不一定，因为他映射的几个点x2已经映射过了。

![img](https://p-blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf3.jpg)

在这个结构里面与传统hash比较特别的地方就是存储的值，是存储的0，1，因此每位只有1bit，这样比普通直接存值可以少上很多的空间。

不妨计算一下，平均一串字符串10个字符，

## 三、实现

知道了结构那么实现起来也就没那么复杂了，

## 四、错误率

上面一直提到错误率，那么这个错误率该怎么计算呢？

让我们来简单的推导一下：

```
1/m -> 1-1/m -> (1-1/m)^k -> (1-1/m)^kn -> (1-(1-1/m)^kn)^k
 -> (1-e^(-kn/m))^k
```

从上面的推导来看也就是：P(假阳性率) = (1-e^(-kn/m))^k

## 五、优缺点

### 5.1 优缺点



### 5.2 改良



## 六、使用场景

