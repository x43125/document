# 算法4 第二章

> 排序



## 一、初级排序算法

对于排序算法的复杂度分析主要包括：比较和交换的次数，或是对数组的读写情况

### 1.1 选择排序

遍历所有元素，找到最小的那个元素，与第一个元素交换位置。再从第2个元素开始遍历剩余元素找到最小元素，与第2个元素交换位置，依此类推，直到全部交换完毕。

因为它每次都是从剩余元素中选择一个最小的进行排序，所以叫：**选择排序**

比较次数：N(N-1)/2

交换次数：N

> 一般来说：算法越简单复杂度越高

特点：

- 运行时间与输入次序无关
- 交换次数最小

### 1.2 插入排序

像理桥牌一样一张一张把桥牌插到已经有序的牌的正确位置

核心：从第**2**张牌开始，和前面的已经排好序的牌做比较，如果比前一张牌小，则交换位置。依此类推，直到全部交换完毕，开始下一轮，i向后移动1位。

每次固定一张牌的位置，每轮最坏情况，比较i-1次，共比较n-1轮，所以是1 + 2 + 3 + ... n-1 次共 n(n-1)/2 次

### 1.3 希尔排序

> 插入排序的优化改良版，通过将数据分组排序，来增加数组的有序性，然后使用插入排序

先制定出一个间隔gap，然后将数组按照每gap数分组，

即第一组：第一个数是0，第二个数是0+5，第三个数是0+5+5

第二组：第一个数是1，第二个数是1+5，第三个数是1+5+5

| gap      | 数组                | 分组                    |
| -------- | ------------------- | ----------------------- |
| 5        | h e l l o w o r l d | h w; e o; l r; l l; o d |
| 2        | h e l l d w o r l o | h l d o l; e l w r o    |
| 1        | d e h l l o l r o w | d e h l l o l r o w     |
| 最终结果 | d e h l l l o o r w |                         |

#### 1.3.1 实现

第一层主要负责每一次排序的分组

第二、三层负责插入排序

其中第二层负责for循环本次待排序数据

第三层负责将本次待排序数据，插到指定位置

```java
public static void shellSort(Comparable[] a) {
  int n = a.length;
  for (int gap = n/2; gap > 0; gap /= 2) {
    for (int i = gap; i < n; i++) {
      for (int j = i; j > gap && less(a[j], a[j-gap]); j -= gap) {
        exch(a, j, j - h);
      }
    }
  }
}
```

## 二、归并排序

### 自顶向下归并

> 分治法的标准案例

```java

    private Comparable[] aux;

    private void merge(Comparable[] a, int low, int mid, int high) {
        int i = low, j = mid + 1;
        for (int k = low; k <= high; k++) {
            aux[k] = a[k];
        }

        for (int k = low; k <= high; k++) {
            if (i > mid) {
                // 左边用完了，则统一从右边取数据
                a[k] = aux[j++];
            } else if (j > high) {
                // 右边用完了，则统一从左边取数据
                a[k] = aux[i++];
            } else if (less(aux[j], aux[i])) {
                // 都没用完，则比较后取出更小的那个
                a[k] = aux[j++];
            } else {
                a[k] = aux[i++];
            }
        }
    }

    private void sort(Comparable[] a, int low, int high) {
        // 递归退出条件
        if (high <= low) {
            return;
        }

        // 找到中点继续递归
        int mid = low + (high - low) / 2;
        // 递归merge左侧
        sort(a, low, mid);
        // 递归merge右侧
        sort(a, mid + 1, high);
        // 将左右两侧已经排好序的数组合并到原数组中
        merge(a, low, mid, high);
    }

    public void sort(Comparable[] a) {
        // 辅助数组
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }
```





































































