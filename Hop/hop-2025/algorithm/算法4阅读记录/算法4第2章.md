# 算法4 第二章

> 排序



## 一、初级排序算法

对于排序算法的复杂度分析主要包括：比较和交换的次数，或是对数组的读写情况

### 1.1 选择排序

遍历所有元素，找到最小的那个元素，与第一个元素交换位置。再从第2个元素开始遍历剩余元素找到最小元素，与第2个元素交换位置，依此类推，直到全部交换完毕。

因为它每次都是从剩余元素中选择一个最小的进行排序，所以叫：**选择排序**

比较次数：N(N-1)/2

交换次数：N

> 一般来说：算法越简单复杂度越高

特点：

- 运行时间与输入次序无关
- 交换次数最小

### 1.2 插入排序

像理桥牌一样一张一张把桥牌插到已经有序的牌的正确位置

核心：从第**2**张牌开始，和前面的已经排好序的牌做比较，如果比前一张牌小，则交换位置。依此类推，直到全部交换完毕，开始下一轮，i向后移动1位。

每次固定一张牌的位置，每轮最坏情况，比较i-1次，共比较n-1轮，所以是1 + 2 + 3 + ... n-1 次共 n(n-1)/2 次

### 1.3 希尔排序

> 插入排序的优化改良版，通过将数据分组排序，来增加数组的有序性，然后使用插入排序

先制定出一个间隔gap，然后将数组按照每gap数分组，

即第一组：第一个数是0，第二个数是0+5，第三个数是0+5+5

第二组：第一个数是1，第二个数是1+5，第三个数是1+5+5

| gap      | 数组                | 分组                    |
| -------- | ------------------- | ----------------------- |
| 5        | h e l l o w o r l d | h w; e o; l r; l l; o d |
| 2        | h e l l d w o r l o | h l d o l; e l w r o    |
| 1        | d e h l l o l r o w | d e h l l o l r o w     |
| 最终结果 | d e h l l l o o r w |                         |

#### 1.3.1 实现

第一层主要负责每一次排序的分组

第二、三层负责插入排序

其中第二层负责for循环本次待排序数据

第三层负责将本次待排序数据，插到指定位置

```java
public static void shellSort(Comparable[] a) {
  int n = a.length;
  for (int gap = n/2; gap > 0; gap /= 2) {
    for (int i = gap; i < n; i++) {
      for (int j = i; j > gap && less(a[j], a[j-gap]); j -= gap) {
        exch(a, j, j - h);
      }
    }
  }
}
```

## 二、归并排序

### 2.1 自顶向下归并

> 分治法的标准案例

递归将数组分割成两份，直到分割成最小的时候，排序并合并左右两个数组

> tip: 改进方法并非是为了让你完全实现所有改进方法，而是让你不要对一个解法就盖棺定论，要时刻保持怀疑，是否能有更优解，是否还能优化。这种心理才是最宝贵的，而不是得到一个答案就停滞不前。

### 2.2 自底向上归并

一开始就从最底层进行合并，然后一点点调大每次需合并的宽度，直到最后所有值合并

```java
public void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        int n = a.length;
        // 外层控制本次的数组大小，sz表示左右数组各只有一个元素
        for (int sz = 1; sz < n; sz *= 2) {
            // 拿sz=1代表：每次merge 第一个和第二个数组，然后跳转到下一对数组所以(low += (sz * 2))
            for (int low = 0; low < n - sz; low += (sz * 2)) {
                // 到最后一组的时候，右侧数量可能不等于左侧，所以要比较 n-1，防止数组下标越界
                merge(a, low, low + sz - 1, Math.min(low + 2 * sz - 1, n - 1));
            }
        }
    }
```



## 三、快速排序

> 快排也是一种分治思想的排序算法

通过每次将一个数据固定到应该待的位置，然后不断的重复来实现最终排序。怎么找到一个数据的应该待的位置呢？那么则是遍历整个数组，将比它小的数都放到它左边，将比它大的数都放到它右边。然后重复他两边的数据，直到最后得到一个完整的排序的数组。

那么快排则分为两个步骤：1.找到该待的位置，2.递归查找左右



递归体:

```java
private void sort(Comparable[] a, int low, int high) {
  if (high <= low) return;
  int j = partition(a, low, high);
  sort(a, low, j-1);
  sort(a, j+1, high);
}
```

找到本次递归待定位的数的位置并将该数移动到该待的位置

```java
private int partition(Comparable[] a, int low, int high) {
  int i = low, j = high + 1;
  Comparable v = a[low];
  while(true) {
    while(less(a[++i], v) && i < high);
    while(less(v, a[--j]) && j > low);
    if (i >= j) {
      break;
    }
    exch(a, i, j);
  }
  exch(a, low, j);
}
```

## 四、有序队列

>  堆排序

每次插入或删除，都会动态的将数组调整为指定的最大堆情况，每一轮都可以获取到最大值

可以使用数组来实现堆的结构，也就是完全二叉树的结构。

核心就是，当插入一个数的时候，如何将该数挪到目标位置；及当删除最大值的时候，如何将剩下的结构调整成符合要求的大顶堆结构

```java

    // 上浮和插入值有关
    // 会上浮到目标位置
    private void swim(int k) {
        // 因为在数组中根节点在第1位，所以k要>1
        // 如果子节点小于根节点，则交换两个节点
        while (k > 1 && less(k/2, k)) {
            exch(k/2, k);
            k = k/2;
        }
    }

    /**
     * 下沉则和删除最大值有关
     * @param k
     */
    private void sink(int k) {
        // 如果有子节点的话
        while (2 * k <= n) {
            // 计算子节点
            int j = 2 * k;
            // 如果子节点存在，且有右子节点，则比较左右节点谁更大，来决定替换谁
            if (j < n && less(j, j+1)) {
                j++;
            }
            // 如果>=更大的节点的话，则不需要再比较了，此位置就是它应该待的位置
            if (!less(k, j)) {
                break;
            }
            // 否则和两节点中更大的那个替换位置，然后进入下一轮比较
            exch(k, j);
            k = j;
        };
    }
```





























































