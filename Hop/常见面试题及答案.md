# 常见面试题及答案

1、延时队列的原理

DelayQueue是一个基于PriortyQueue的BlockingQueue，他**包装**了 PriortyQueue，他可以根据时间大小来排序任务，这样就可以让时间越小的任务越先执行。

它是J.U.C包下的一个类，是线程安全的。

想要使用这个队列的话，他的元素需要实现Delayed接口，并实现其内的两个方法：

- getDelay `计算该任务距离过期还有多少时间`,

- compareTo `比较、排序使用，用来对延时队列进行比较，时间近的放在队首`

2、红黑树

自平衡二叉查找树，他的结构很复杂，**但有着较良好的最差时间复杂度**，他可以在O(logN)的时间复杂度下完成 查找、删除、增加操作

性质：

- 节点是红色或黑色
- 根节点是黑色的
- 所有叶子结点都是黑色的，且为空节点 NIL
- 每个红色节点的两个字节点都是黑色的
- 从**任一节点**到其**每个叶子**的所有简单路径都包含**相同数目的黑色节点**

3、快速排序

先选中一头的点，然后从两头遍历，将小于它的数值放到它的左边，将大于它的数值放到它的右边。一次循环后会形成一个

小于x的数  x 大于x的数 这样的一个结构。

然后再继续按照这个方式递归来找x左右两侧的数值。

```java
class QuickSort {
    private static void sort(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }

        int i = left, j = right, x = nums[left];
        while (i < j) {
            while (i < j && nums[j] >= x) {
                j--;
            }
            if (i < j) {
                nums[i] = nums[j];
            }
            while (i < j && nums[i] <= x) {
                i++;
            }
            if (i < j) {
                nums[j] = nums[i];
            }
        }

        nums[i] = x;
        quickSort(nums, 0, left - 1);
        quickSort(nums, left + 1, right);
    }
}
```

4、归并排序

```java
class MergeSort {
    /**
     * 自顶向下
     * @param nums
     */
    private static void sort(int[] nums) {
        if (nums == null) {
            return;
        }

        mergeSort(nums, 0, nums.length - 1);
    }

    private static void mergeSort(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }

        int mid = (left + right) / 2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        merge(nums, left, mid, right);
    }

    /**
     * 合并两个有序数组
     *
     * @param nums
     * @param left
     * @param mid
     * @param right
     */
    private static void merge(int[] nums, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, y = 0;

        while (i <= mid && j <= right) {
            if (nums[i] < nums[j]) {
                temp[y++] = nums[i++];
            } else {
                temp[y++] = nums[j++];
            }
        }

        while (i <= mid) {
            temp[y++] = nums[i++];
        }
        while (j <= right) {
            temp[y++] = nums[j++];
        }

        for (int k = left; k <= right; k++) {
            nums[k] = temp[k - left];
        }
    }

    /**
     * 自底向上
     *
     * @param nums
     */
    private static void sort2(int[] nums) {
        int n = nums.length;
        for (int i = 1; i < n; i *= 2) {
            mergeSort2(nums, n, i);
        }
    }

    private static void mergeSort2(int[] nums, int n, int gap) {
        int i;
        for (i = 0; i + 2 * gap - 1 < n; i += 2 * gap) {
            merge(nums, i, i + gap - 1, i + 2 * gap - 1);
        }
    }
}
```

5、MySQL 常见索引

普通索引：加在一列上，值可以重复

唯一索引：加在一列上，值不可以重复

主键索引：每个表都应该有个主键索引

联合索引：加在多个列上，组成联合索引，使用的时候需要尊从最左原则

前缀索引：加在 Blob、TEXT和VARCHAR列，只索引开始部分的字符

6、常见索引结构

Hash: 不适合范围检索

B+树：在B树的基础上，在叶子结点之间增加指针，以支持范围索引

7、聚簇索引 & 非聚簇索引

主键索引的B+树的叶节点存储所有字段信息

其他键的索引的叶节点存储主键的值，需要通过主键到主键的B+树再找一次

8、SQL调优

用Explain来分析执行计划，主要的字段有：

- select_type: 查询类型，有简单查询、联合查询、子查询等
- key: 使用的索引
- rows: 扫描的行数

通过慢查询日志来分析，执行速度较慢的SQL

慢查询日志可以通过配置来输出到日志文件里，或直接输出到慢查询表中

可以人工规定执行多久的算慢查询

优化：

- 业务层
  - 减少返回的行数，只取需要的行数，善用分页查询
  - 减少返回的列数，只取需要的字段，不要使用select * 
  - 缓存需要重复使用的值，不要把一些重复的查询放在for循环里
  - 切分大查询
  - 分解大join查询，放到应用程序里做联合操作
- 数据层
  - 合理创建索引：给经常需要查询的列设置索引
  - 索引覆盖查询：给需要查询多个列的设置联合索引
  - 正确使用索引，避免索引失效的情况
- 拆分
  - 如果表的数据过多：可以进行拆分
    - 水平拆分：创建相同的数据库和表，存储相同属性的值
    - 竖直拆分：将经常使用的列，或不经常使用的列，单独拆分出来成一张表
  - 主从复制：读写分离，配置读写分离的主从结构，一个只用于读，这样很少会有锁的情况，可以节省时间。也可以将其存储引擎改为MyISAM，MyISAM比InnoDB读取速度更快。

9、MySQL读写分离 & 主从复制

主从复制涉及三个线程：

- binlog线程：将主服务器的数据变更写到二进制日志中
- I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中
- SQL线程：负责读取中继日志中并重放其中的SQL语句

10、MVCC

Multi-Version-Concurrency-Control 多版本并发控制

11、回表

指：聚簇索引的其他索引需要先扫到主键，再根据主键来检索一次



分布式经验 & 高并发经验 场景等等，tmd，不信老子不会了







## 场景题：

![image-20230716094031955](/Users/wangxiang/Library/Application Support/typora-user-images/image-20230716094031955.png)







综合题：

- 你项目的亮点？你最有成就感的事？最困难的问题？最印象深刻的事情？
  - 解决复杂问题的能力：哪些复杂/有挑战的问题
  - 做了提高效率的工作：重构代码；优化数据库查询效率；引入异步线程；开发了某个公共组件
  - 团队协作/沟通能力：核心开发/小组长；通过管理手段按时完成项目交付；提高了质量
