# 八股文记录



## 分布式

### 零、分布式基础

分布式系统是一个硬件和软件等分布在不同网络计算上，彼此间只通过消息传递进行通信和协调的系统。

简单说：多个普通计算机共同对外提供服务，但是对于系统用户来说，感知不到多计算机的存在。

为什么要分布式：多个的普通计算机比单个的大型机更加便宜，更加易扩展，更加容易维护，出问题更加容易解决或直接替换，也更容易做灾备。

最大的特点：分布式主机之间通过网络来传递信息。

分布式的问题：

- 缺乏全局时钟
- 机器宕机问题
- 网络异常
- 分布式三态：成功，失败，超时（未知）
- 存储数据丢失

衡量指标：

- 性能
- 可用性
- 可扩展性
- **一致性**

分布式理论基础

CAP理论：一致性、可用性、分区容错性，三者不能同时满足，最多只能满足其中**两个**

BASE理论：基本可用、软状态、最终一致性，其中软状态和最终一致性这两种技巧擅长对付存在分区的场合，并因此提高了可用性



### 一、分布式事务

1. 问题的由来
   1. 在传统的系统中，因为是单服务，所以每个原子操作都只会在同一个服务中，那么直接在当前代码中添加事务即可。
   2. 但在微服务中，数据库和应用服务的拆分，导致原本一个事务单元的多个操作，变成了跨进城或跨数据库的多个DML操作了。

分类：

1、强一致性（刚性事务） CP

- 2PC
- 3PC

2、弱一致性（柔性事务） AP

- 基于业务层

  - TCC

  - SAGA

- 最终一致性

  - 本地消息表

  - 消息队列

  - 最大努力通知

### 二、分布式ID

1. 问题的由来
   1. 在传统的单服务系统中，所有创建ID的操作都在同一个服务中，都依赖于同一个数据库，自然也就只需要使用数据库本身的自增ID即可；
   2. 但在分布式系统中，我们通常会分库、分表，多个库或多个表存储相同结构的数据，这种情况下，自然就不能再简单的使用数据库本身的自增ID了，因为这样，虽然在单体的数据库中ID是自增唯一的，但在系统层面会出现重复的ID，也就不满足要求了。因此需要一个全局的唯一ID生成器来统一生成ID。业务在拿到此唯一ID后再主动插入到某节点的表中，从而可以保证多个节点上的表中的ID唯一。
2. 解决
   1. UUID：32位数的16进制数字组成，理论上可以有：16^32 也就是 2^128 个范围，简称：不可能用完
      1. 但其很长，占空间，可读性差，非递增不利于索引更新
   2. 数据库生成：起始值设置成节点序号，然后根据节点数作为步长向后自增
      1. 比如：3个节点的数据库，则3个表的ID分别从 0，1，2 开始递增，步长为3，即下一个数为：3，4，5；这样则不会出现重复问题。
      2. 但这样高度依赖数据库：比如主从切换的时候，可能会导致数据不一致；发号瓶颈限制在单台MySQL的读写性能
   3. Redis生成：redis提供 `incr` 和 `incrby` 这样的自增原子命令，由于Redis自身的单线程特点，所以能保证ID的唯一有序性。 但是单线程可能存在性能瓶颈，所以可以采用集群方式，集群和数据库一样会出现重复问题，所以也需要设置不同的起点和步长。
   4. 雪花算法（Snowflake）：其组成为：1bit符号位 + 41bit精确到毫秒的时间戳 + 10bit机器数 + 12bit自增序列
      1. 与时间有关，如果回拨时间，恰巧回拨的时间区间里创建过ID，则可能会生成重复ID；官方针对这种重复只是做了抛错，并无其他处理。
   5. 百度 UidGenerator：基于Snowflake；有两种生成方式：一种是除了区域划分不同其余与Snowflake基本一致；一种是RingBuffer类型
   6. 美团 Leaf：也有两种生产方式：一种是基于数据库生成方案，每次由proxy server批量获取ID，然后耗尽之后再取下一批ID，这样减少对数据库的IO；另一种也是基于Snowflake的，他的ID划分区域与Snowflake一致，只是在workerId的分配上引入了zookeeper，由zookeeper来自动配置workerId。
   7. 薄雾算法 Mist：按序递增，不可预测，可适用范围大，比Snowflake快很多，但是重启后会使按序递增数值恢复初始值。



### 三、分布式锁





### 四、分布式一致性算法

### 1、一致性Hash算法



### 2、Paxos算法



### 3、Raft算法



### 4、ZAB算法



## Spring Cloud

> 一套分布式微服务的技术解决方案，它提供了快速构建分布式系统的常用组件
>
> Spring cloud是Spring官方提供的一套微服务标准，目前使用比较多的有以下两套。

- spring-cloud netflix
  - Ribbon - 负载均衡
  - Hystrix - 服务熔断
  - Zuul - 网关
  - Eureka - 服务注册中心
  - Feign - 服务调用
- spring-cloud alibaba
  - Dubbo - 消息通讯
  - Nacos - 服务注册中心
  - Seata - 事务隔离
  - Sentinal - 熔断降级

有了这样的技术生态，我们在实际构建微服务架构的时候，就无须再考虑集成第三方技术的成本了，只有通过配置即可，从而可以让我们更加注重业务本身。



### Spring-cloud alibaba

#### Seata

#### Dubbo

Dubbo是一款高性能、轻量级的RPC框架，提供了分布式架构下的服务之间的通信方案，使得开发者不需要关心网络通信的细节。通过该框架可以使得远程服务调用方式和本地服务调用方式一样简单。由十层模式构成

| 分层     | 细分       | 描述                                         | API/SPI |
| -------- | ---------- | -------------------------------------------- | ------- |
| Business | service    | 业务逻辑层，提供接口和实现                   | API     |
| RPC      | config     | 配置层，用于初始化配置信息                   | API     |
|          | proxy      | 代理层，提供consumer和provider的代理         | SPI     |
|          | register   | 服务注册层，封装服务地址的注册和发现         | SPI     |
|          | cluster    | 路由层，封装provider路由和负载均衡           | SPI     |
|          | monitor    | 监控层，提供RPC调用时间和次数监控            | SPI     |
|          | protocol   | 远程调用层，封装RPC调用                      | SPI     |
| remoting | exchange   | 信息交换层，用于封装请求响应模式，同步转异步 | SPI     |
|          | transport  | 网络传输层，对netty和mina的封装              | SPI     |
|          | seriallize | 序列化层，提供数据的序列化和反序列化         | SPI     |

Dubbo与Spring Cloud的区别：

Dubbo是SOA时代的产物，关注点在于服务的调用，流量分发，流量监控和熔断。而Spring Cloud诞生于微服务架构之上，考虑的是微服务治理的方方面面，

Nacos：注册和配置中心

Sentinal









## Redis



### 常见问题处理

#### 1、缓存穿透

**用户不断请求，缓存和数据库中都不存在的数据。**由于缓存一般是在未命中缓存层，而命中了数据库层的时候被动写的，所以这种两边都不存在的数据不会维护到缓存中，那么这样的请求就会每次都落到数据库，缓存也就失去了意义。

如果是少数正常用户访问错误，那就还好，但如果是恶意攻击，大量的发送这种请求，可能会导致DB挂掉。

##### 根据上述描述解决方案有：

- 应用层：做基础的校验，比如ID<0的直接拦截；接口层做鉴权校验等

- **将这种数据也存到缓存中**，这样下次再访问的时候，就能在缓存中知道不存在这个数据，而无需再访问数据库。但这样的话，如果数据量大，又会占用缓存空间，影响正常的数据缓存。这种数据，往往只会在短时间内进行大量的请求，所以可以给他们**设置一个较短的过期时间**，让他们过期后自动删除，即可以解决
- 布隆过滤器：特点：布隆过滤器判断存在的不一定会存在，但判断不存在的一定不存在。我们可以在缓存层和业务层之间再加一个布隆过滤器，布隆过滤器本质上是一个HashSet，在这个set中存储数据的key，过来的请求经过布隆过滤器计算之后，如果存在对应的值则继续向下访问，如果不存在则直接拦截。

#### 2、缓存雪崩

**是指大量请求请求缓存中不存在但数据库中存在的数据。**

针对这一描述，有两种场景可能会导致：1. 缓存层宕机，大量请求直接落到数据库层；2. 大量数据同一时间过期，此时大量请求会直接落到数据库层

##### 解决方案

- 针对第一种：
  - 可以设置缓存层备份，如主从备份等高可用方案，来避免突然宕机
  - 做好熔断、降级处理，当突然宕机的时候可以快速应对
- 针对第二种：
  - 尽量分散设置key的过期时间，让不同的数据均匀分布在不同时间过期
  - 也可以像缓存击穿一样，针对某些热点数据设置不过期
  - 如果缓存是分布式部署的，可以将数据均匀分布在不同的节点，减少同时过期的可能性

#### 3、缓存击穿

**是指当缓存中的某个热点数据过期了，导致大量请求落到数据库的问题**

##### 解决方案

- 设置热点数据不过期
- 加互斥锁，其他请求等待第一条读取的数据重新更新到缓存中后，再从缓存中取





