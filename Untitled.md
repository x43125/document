# [iOS 卡顿 & ANR 监控原理及实践](https://wiki.enmonster.com/pages/viewpage.action?pageId=207472280)

[Skip to end of metadata](https://wiki.enmonster.com/pages/viewpage.action?pageId=207472280#page-metadata-end)

- Created by [李 江鹏](https://wiki.enmonster.com/display/~lijiangpeng), last modified on [May 08, 2024](https://wiki.enmonster.com/pages/diffpagesbyversion.action?pageId=207472280&selectedPageVersions=6&selectedPageVersions=7)

[Go to start of metadata](https://wiki.enmonster.com/pages/viewpage.action?pageId=207472280#page-metadata-start)

# 卡顿⽅案

卡顿就是在应⽤使⽤过程中出现界⾯不响应或者界⾯渲染粘滞的情况。⽽应⽤界⾯的渲染以及事件响应是在主线程完成的，出现卡顿的原因可以归结为主线程阻塞。

### **可能造成卡顿的原因：**

**多线程死锁**：主线程拿到锁 A，需要获得锁 B，⽽同时某个⼦线程拿了锁 B，需要锁 A，这样相互等待就死锁了。

比较常见的就是在 `dispatch_once` 中子线程同步访问主线程，最终造成死锁的问题

1. 子线程先进入 `dispatch_once` 的 block 中并加锁。
2. 然后主线程再进入 `dispatch_once` 并等待子线程解锁。
3. 子线程初始化时触发了 `CTTelephonyNetworkInfo` 对象初始化抛出了一个通知却要求主线程同步响应，这就造成了主线程和子线程因为互相等待而死锁，最终触发了卡死崩溃。

实践

子线程不要有同步主线程执行的方法。



**抢锁：**主线程需要访问 DB，⽽此时某个⼦线程往 DB 插⼊⼤量数据。通常抢锁的体验是偶尔卡⼀阵⼦，过会就恢复了。

一个比较典型的问题是卡死在`-[YYDiskCache containsObjectForKey:]`，`YYDiskCache` 内部针对磁盘多线程读写操作，通过一个信号量锁保证互斥。通过分析卡死堆栈可以发现是子线程占用锁资源进行耗时的写操作或清理操作引发主线程卡死

实践

1. 有可能存在锁竞争的代码尽量不在主线程同步执行。
2. 如果主线程与子线程不可避免的存在竞争时，加锁的粒度要尽量小，操作要尽量轻。



**主线程在进⾏⼤量**I/O**操作**：为了⽅便代码编写，直接在主线程去写⼊⼤量数据。

此类问题，表现形式可能多种多样，但是归根结底都是因为磁盘 IO 过于密集最终导致主线程磁盘 IO 耗时过长。典型 case:

1. 主线程压缩/解压缩。
2. 主线程同步写入数据库，或者与子线程可能的耗时操作（例如 `sqlite` 的 `vaccum` 或者`checkpoint` 等）复用同一个串行队列同步写入。
3. 主线程磁盘 IO 比较轻量，但是子线程 IO 过于密集，常发生于一些低端设备。

实践

1. 数据库读写，文件压缩/解压缩等磁盘 IO 行为不放在主线程执行。
2. 如果存在主线程将任务同步到串行队列中执行的场景，确保这些任务不与子线程可能存在的耗时操作复用同一个串行队列。
3. 对于一些启动阶段非必要同步加载并且有比较密集磁盘 IO 行为的 SDK，如各种支付分享等第三方 SDK 都可以延迟，错开加载。



**主线程在进⾏⼤量计算**：代码编写不合理，主线程进⾏复杂计算。

**⼤量**UI**绘制**：界⾯过于复杂，UI绘制需要⼤量时间。

**存储空间不足**：根据 Apple 官方支持页面，为了获得最佳性能，建议至少保持 1GB 的可用存储空间。如果可用空间少于 1GB，设备可能会变慢，因为 iOS 需要不断腾出空间来存储其他内容。

**网络连接问题**：网络拥堵或连接不稳定也可能导致应用加载缓慢或卡顿，尤其是在需要大量数据传输的应用中更为明显；



### 卡顿带来的影响：

**用户体验下降**：卡顿会直接影响用户的操作体验，导致用户无法流畅地使用；

**效率降低**：卡顿可能导致用户在执行任务时需要等待更长时间，降低工作效率；

**电池消耗增加**：为了维持应用的运行，设备可能需要更多的 CPU 和 GPU 资源，这会增加电池的消耗；

**应用稳定性问题**：长期的卡顿可能导致应用崩溃，影响应用的稳定性



## CPU和GPU

在屏幕成像的过程中，CPU和GPU起着至关重要的作用

### CPU（Central Processing Unit）中央处理器

负责：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式和解码、图像的绘制（Core Graphics)

### GPU（Graphics Processing Unit）图形处理器

负责：纹理的渲染

![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-5-7_20-21-25.png?version=1&modificationDate=1715084486000&api=v2)



iOS中是双缓冲机制，有前帧缓存、后帧缓存

### 屏幕成像原理

![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-5-7_20-25-12.png?version=1&modificationDate=1715084712000&api=v2)

屏幕显示过程中，一帧画面会发出垂直同步信号，然后依次一行一行发出水平同步信号。连起来就是屏幕成像。





**卡顿⽅案分类**：
检测的⽅案根据线程是否相关分为两⼤类：与主线程相关的检测⽅案包括：FPS、ping、Runloop；与主线程不相关的检测有：msgSend observe
1、FPS（Frames Per Second）
Frames Per Second，每秒渲染帧数。向主线程的RunLoop的添加⼀个commonModes的CADisplayLink，每次屏幕刷新的时候都要执⾏CADisplayLink的⽅法，统计的1s内屏幕刷新次数即为FPS。

 Expand source



缺点：FPS 不好衡量，抖动⽐较⼤

2、Runloop
基于Runloop检测，使⽤⼦线程实时检测Runloop状态，执⾏超过指定时间则判定为卡顿。⼦线程实时计算 kCFRunLoopBeforeSources (即将触发source0回调)和 kCFRunLoopAfterWaiting（即将进⼊休眠） 两个状态区域之间的耗时是否超过某个阀值，以此来断定主线程的卡顿情况。

可以有不同的定义：设置连续5次超时50ms认为卡顿 or 连续3次超时80ms认为卡顿 or 超过阈值即为卡顿 （多次连续⼩卡顿、单次⻓时间卡顿）

![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-4-26_15-49-28.png?version=1&modificationDate=1714117769000&api=v2)

 Expand source



3、**⼦线程Ping**
卡顿发⽣时，主线程会出现短时间内⽆响应这⼀表现，使⽤⼦线程定时向主线程中仍⼊任务，超过指定时间任务未被执⾏则判定为卡顿。创建⼀个⼦线程通过信号量去ping主线程，因为ping的时候主线程肯定是在kCFRunLoopBeforeSources和kCFRunLoopAfterWaiting之间。每次检测时设置标记位为YES，然后派发任务到主线程中将标记位设置为NO。接着⼦线程沉睡超时阈值时⻓，判断标志位是否成功设置成NO，如果没有说明主线程发⽣了卡顿。

![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-4-26_15-50-38.png?version=1&modificationDate=1714117838000&api=v2)

缺点：但是由于主线程的RunLoop在闲置时基本处于Before Waiting状态，这就导致了即便没有发⽣任何卡顿，这种检测⽅式也总能认定主线程处在卡顿状态。

 Expand source



代表：[ANREye](https://github.com/zixun/ANREye)

4、msgSend observe
OC⽅法的调⽤最终转换成msgSend的调⽤执⾏，通过在函数前后插⼊⾃定义的函数调⽤，维护⼀个函数栈结构可以获取每⼀个OC⽅法的调⽤耗时，以此进⾏性能分析与优化为了更好的选择所需的⽅案，需要建⽴⼀套衡量指标来对⽅案进⾏对⽐。

 Expand source



总结的衡量指标包括四项：

| 方案           | 卡顿反馈                                                     | 采集精度                                                     | 性能损耗                                                     | 实现成本                                           | 结论                                             |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------------------------------------------------- | :----------------------------------------------- |
| FPS            | 卡顿发⽣时，FPS明显下降（⾼）                                | 回调总是需要CPU空闲才能处理，⽆法及时采集调⽤栈信息。（低）  | 监听屏幕刷新会频繁唤醒RunLoop，闲置状态下有⼀定的损耗。（中低） | CADisplayLink实现。（低）                          | 更适⽤于开发阶段，线上可作为辅助⼿段             |
| Ping           | 主线程出现堵塞直到空闲期间都⽆法回包，但在ping之间的卡顿存在漏查情况（中⾼） | ⼦线程在Ping前能获取主线程准确的调⽤栈信息。（中⾼）         | 需要常驻线程和采集调⽤栈。（中）                             | 需要维护⼀个常驻线程，以及对象的内存控制。（中低） | 监控能⼒、性能损耗和ping频率都成正⽐，监控效果强 |
| RunLoop        | RunLoop的不同阶段把时间分⽚，如果某个时间⽚太⻓，基本认定发⽣了卡顿。此外应⽤闲置状态常驻beforeWaiting阶段，此阶段存在误报可能。（中） | 和FPS类似，依附于主线程callback的⽅案缺少准确采集调⽤栈的时机，但优于FPS检测⽅案。（中低） | 此⽅案不会频繁唤醒RunLoop，相较于FPS性能更佳。（低）         | 注册RunLoop observer。（中低）                     | 综合性能优于fps，但反馈表现不⾜                  |
| msgSendobserve | （⾼）                                                       | （⾼）                                                       | 拦截后调⽤频次⾮常⾼，启动阶段可达10w次以上调⽤。（⾼）      | 需要维护⽅法栈和优化拦截算法。（⾼）               | 准确率很⾼的⼯具，但不适⽤于Swift代码            |

**⽬标**：**⾼卡顿反馈、⾼采集精度、低性能损耗、低实现成本**

# **业****内****⽅****案****：**

### Matrix**卡顿⽅案** 原理：卡顿监控起⼀个⼦线程定时检查主线程RunLoop的状态，当主线程的状态运⾏超过⼀定阈值则认为主线程卡顿，从⽽标记为⼀个卡顿。

![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-4-26_15-59-2.png?version=1&modificationDate=1714118342000&api=v2)

**如何判断主线程了发⽣卡顿？（微信**Matrix**⽅案）**

1、主线程 Runloop 运⾏超过阈值（默认2s）

2、单核 CPU 的占⽤超过了 80%

**如何提取耗时堆栈？**

定时获取主线程堆栈，并将堆栈保存到内存的⼀个循环队列中。微信的策略是每隔 50 ms获取⼀次主线程堆栈，保存最近 20 个主线程堆栈。这个会增加 3% 的 CPU 占⽤，内存占⽤可以忽略不计。

Matrix 卡顿监控⽤如下特征找出最近最耗时堆栈：

以栈顶函数为特征，认为栈顶函数相同的即整个堆栈是相同的；

取堆栈的间隔是相同的，堆栈的重复次数近似作为堆栈的调⽤耗时，重复越多，耗时越多；

重复次数相同的堆栈可能很有多个，取最近的⼀个最耗时堆栈。

**如何降低检测线程性能损耗？**

1、检测到卡顿后，先将主线程的堆栈并保存到内存中，⽽不是直接保存到⽂件中
2、对⽐上次卡顿堆栈，不同则写⼊⽂件中。相同则按照斐波那契数列将检查时间递增直到没有遇到卡顿或者主线程卡顿堆栈不⼀样为⽌

ANR⽅案

⽬前业界对 iOS 系统中 App 发⽣的卡死崩溃问题并⽆成熟的解决⽅案，主要原因是：

1. ⼀般⽽⾔⽤户遇到卡死问题的时候并没有耐⼼等待那么久的时间，可能在卡住5s 时就已经失去耐⼼，直接⼿动关闭应⽤或者直接将应⽤退到后台，因此这两种场景下系统也就不会⽣ 成卡死崩溃⽇志。
2.  通常 App 卡死时间超过 20s 之后会触发操作系统的保护机制，发⽣崩溃，此时在⽤户的设备中能找到操作系统⽣成的卡死崩溃⽇志，但是因为 iOS 系统封闭⽣态的关系，App 层⾯没有权限拿到卡死崩溃的⽇志。

# **业****内****⽅****案****：**

### 1、微信Matrix⽅案（排除法）

![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-4-26_15-55-44.png?version=1&modificationDate=1714118145000&api=v2)



### 2、字节跳动⽅案（卡顿8s）

**如何判定⼀次卡顿为⼀次卡死**

**![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-4-26_16-5-32.png?version=1&modificationDate=1714118733000&api=v2)**

**如何提取卡死堆栈**

**![img](https://wiki.enmonster.com/download/attachments/207472280/image2024-4-26_16-7-49.png?version=1&modificationDate=1714118870000&api=v2)**

为了增加卡死调⽤栈的置信度，在超过卡死阈值后，每隔 1s 进⾏⼀次间隔等待的同时，对当前主线程的堆栈进⾏抓取。为了避免卡死时间过⻓造成的线程调⽤栈数量膨胀，最多会保留距离App 异常退出前的最近 10 次主线程调⽤栈。经过多次间隔等待，我们可以获取在 App 异常退出前主线程随着时间变化的⼀组函数调⽤栈。通过这组函数调⽤栈，我们可以定位到主线程真正卡死的原因，并结合卡死时间超过阈值时获取的

相⽐Matrix排除法，能获取到卡死时间，⽅便量化。



倾向于微信Matrix⽅案，原因如下：

1、卡顿⽅案⼤同⼩异，重点在于性能和采集精确度之间的平衡考虑。

2、业内⽅案，微信和字节使⽤的⽅案都是基于RunLoop做采集精确度上的优化。

3、使⽤matrix⽅案，可以复⽤采集精度优化、堆栈解析、数据上报，这些如果全部自己做，⼯作量⼤。

4、matrix⽅案⽬前发现的缺点为：最低卡顿检测间隔是1s，对多次⼩卡顿监测不到。

## 卡顿优化

监控到卡顿之后，我们下一步要做的是处理我们卡顿，那么怎么进行卡顿优化呢，我们分两步进行

### CPU

1. 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑用CALayer取代UIView
2. 不要频繁的调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改
3. 尽量提前计算好布局，在有需要时进行一次性调整对应的属性，不要多次修改属性
4. AutoLayout会比直接设置frame消耗更多的CPU资源
5. 图片的size最好和UIImageView的size保持一致
6. 控制线程的最大并发数量
7. 尽量把耗时的操作放在子线程
   1. 文本处理（尺寸计算、绘制）
   2. 图片处理（解码、绘制）

### GPU

1. 尽量避免短时间内大量的图片的显示，尽可能将多张图片合成一张进行展示
2. GPU能处理的最大纹理尺寸是4096X4096，一旦超过这个尺寸，就会占用CPU资源进行处理
3. 尽量减少视图数量和层次
4. 减少透明的视图（alpha < 1），不透明的就设置opaque为yes
5. 尽量避免出现离屏渲染