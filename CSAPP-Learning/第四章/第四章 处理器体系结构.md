# 第4章  处理器体系结构

处理器可以说是人类最复杂的发明之一，并且发展速度极快，多年前曾听过一期立波秀，他在里面说过一句话：“现在人用着比当初发射阿波罗号还要快上很多的处理器玩着斗地主.......”处理器发展速度可见一斑。

- 处理器被用来执行一系列指令，每条指令实现一个简单的操作如两数相加；
- 指令被编码为一个或多个字节系列组成的二进制格式；
- 一个处理器支持的指令和指令的字节集编码称为他的**指令集体系结构**(Instruction-Set Architecture, ISA)。

处理器非常复杂那我们为什么要学习处理器设计呢？

- 处理器设计非常有趣，非常重要
- 帮助理解计算机操作系统如何工作
- 帮助设计包含处理器的硬件系统
- 设计处理器

本章作者模拟x86-64指令集设计了一套指令集：**Y86-64**

他比x86-64的数据集、指令和寻址方式少了一些，顺序操作、功能正确，每个时钟周期执行一条完整的Y86-64指令的一种流水线化的处理器

总的来说即是一款能用但不实用的指令集（必定是用来学习使用的）

## 4.1  Y86-64 指令集体系结构

通常来说，定义一个指令集体系结构主要有几点：状态单元；指令集；编码；编程规范；异常处理

### 4.1.1  程序员可见状态

”程序员“：使用汇编代码写程序的人；产生机器级代码的编译器

15个程序寄存器：%rax, %rcx, %rdx, %rbx, %rsp, %rbp, %rsi, %rdi, %r8~%r14。比x86-64省了%r15。每个寄存器存储一个64位的字

%rsp被入栈、出栈、调用和返回指定为栈指针

3个一位条件码：ZF, SF, OF

程序计数器：PC

内存：从概念上来说内存就是一个很大的字节数组，保存着程序和数据

程序状态：Stat 指明程序运行的整体状态

### 4.1.2  Y86-64指令

Y86-64指令集基本是x86-64的一个子集

- irmovq, rrmovq, mrmovq, rmmovq 第一个字母为源，第二个字母为目的
- 4个整数操作：OPq：addq, subq, andq, xorq 只对寄存器数据操作
- 7个跳转指令：jmp, jle, jl, je, jne, jge, jg 根据分支指令类型和条件代码设置选择分支
- 6个条件传送：cmovle, cmovl, cmove, cmovne, cmovge, cmovg，与rrmovq类似但只在满足条件时才更新目的寄存器的值
- call: 将返回地址入栈，然后跳转到目的地址；ret: 从调用中返回
- pushq, popq：入栈，出栈
- halt: 停止指令执行



## 4.3 Y86-64的顺序是先

### 4.3.1 将处理组织成阶段

虽然各种不同的指令的动作差异很大，但所有的指令都遵循着统一的序列，将这个序列抽象出来

- 取指：从内存读取指令字节
- 译码：从寄存器文件读入最多两个操作数
- 执行：算数/逻辑单元(ALU)要么执行指令指明的操作计算内存引用的有效地址；要么增加或减少栈指针
- 访存：将数据写入内存，或从内存中读出数据
- 写回：最多写两个结果到寄存器文件
- 更新PC：将PC设置成下一条指令的地址

处理器不断循环的执行这些指令

