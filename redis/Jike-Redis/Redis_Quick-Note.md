# Redis QuickNote

## Redis是如何执行的

简单可以描述为：客户端将用户输入的命令转化为Redis相关的通讯协议，再用socket连接方式将内容发送给服务器端。服务器端收到相关内容后，现将内容转化为具体的执行命令，再判断用户授权信息和其他信息，通过后执行命令。执行完成后进行信息记录和数据统计，然后将执行结果发送给客户端。

如果是集群模式，还将涉及主从节点同步信息等内容。

## 持久化

Redis与Memcached主要区别之一也是Memcached不具备持久化功能

持久化方式：

- 快照方式(RDB, Redis DataBase)：将某一时刻的内存数据，以二进制方式写入磁盘；
- 文件追加方式(AOF, Append Only File)：记录所有操作命令，并以文本形式追加到文件中；
- 混合持久化方式：Redis4.0之后新增的方式，先把当前数据以RDB形式写入文件开头，再将后续操作命令以AOF格式存入文件。

### RDB

手动触发，自动触发

#### 手动触发

命令：save & bgsave 阻塞主线程 & 不阻塞

#### 自动触发

1. save m n: 在m秒内，如果有n个键发生变化，则自动触发持久化，**当设置了多个命令时，满足任意一个条件都会触发持久化**。
2. flushall: 命令用于清空Redis数据库，当Redis执行该命令后，会自动触发持久化，把RDB文件清空！！！请谨慎使用该命令。
3. 主从同步触发：当在主从复制中，当从节点执行全量复制操作时，主节点会执行 bgsave 命令，并将RDB文件发送给从节点，该过程会自动触发 Redis的持久化。

#### 优点

- 以二进制形式存储，占用空间小，紧凑，适合作为备份文件，可以更好的传输
- 读取速度更快

#### 缺点

- RDB只能保存某个时间间隔的数据，如果Redis服务器意外终止了，则会丢失一段时间内的数据
- RDB需要经常fork()才能使用子进程持久化，如果数据集很大可能会很耗时，并且如果CPU性能不佳，可能会停止为客户端服务几毫秒到一秒钟。

### AOF

#### 自动触发

- 满足设置的触发策略
- 满足AOF重写触发

##### 触发策略

- always:  每条Redis命令都会写入磁盘，最多丢失一条数据
- everysec: 每秒钟写入一次磁盘，最多丢失一秒数据
- no: 不设置写入规则，根据当前操作系统来决定何时写入磁盘，Linux默认30s写入一次

##### 设置方式

```sh
appendfsync everysec
```

#### AOF重写触发

将冗余的命令合并后记录，可以大幅度压缩存储空间。

 ##### 手动触发

客户端执行 `bgrewriteaof` 命令触发

#### 加载规则

- 如果只开启了AOF，启动时只加载AOF
- 只开启了RDB，启动时只加载RDB
- 同时开启，启动时只加载AOF，即使AOF文件不存在，也不会加载RDB

#### 异常数据恢复

`aof-load-truncated`忽略最后一条命令

`redis-check-aof`跳转到问题行

`redis-check-aof --fix` 自动修复AOF异常文件（可能会导致异常部分至文件末尾的数据被丢弃）

### 混合持久化

混合持久化加载流程

1. 判断是否开启AOF，开启则继续执行，否则开启执行RDB文件的流程；
2. 判断appendonly.aof文件是否存在，存在继续执行；
3. 判断AOF文件开头是RDB格式，先加载RDB内容再加载剩余的AOF内容；

> 混合型AOF文件是以 `REDIS`开头的，非混合型是以`*`开头的

1. 判断开头不是RDB格式，直接以AOF格式加载整个文件。

#### 优点

结合了RDB和AOF的优点，既能更快的启动，占用更少的磁盘空间，又能减低大量丢失数据的风险。

#### 缺点

AOF文件的可读性变差了

兼容性变差，Redis4.0之后新增的方式，之前不支持

### 持久化最佳实践

#### 1）开关

如果对数据丢失不敏感，则关闭持久化。

#### 2）主从部署

使用主从模式，一台响应主业务，一台持久化

#### 3）混和持久化

混合持久化结合了RDB和AOF的优点，Redis5.0默认开启

#### 4） 增加配置

Redis对CPU要求不高，对内存和磁盘的要求高一些，可考虑升级或增加相应配置。

























































